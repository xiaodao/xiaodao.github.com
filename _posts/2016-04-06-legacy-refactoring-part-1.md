---
layout: post
title: 高速公路换轮胎——为遗留系统替换数据库(上)
category: 朝花夕拾
tags: 工作
---


## 背景 ##

没有人喜欢遗留系统，”遗留“这个词本身就意味着难以理解、难以维护的代码，同时也意味着每一次改动，每一次增加新特性都步履维艰。然而在我们的职业生涯中，又总是难免与遗留代码相逢，因为如果没有清晰的设计意图贯穿软件的整个生命周期，没有持续演进架构，没有持之以恒的良好重构素养，今天的优秀设计就会成为明天的遗留代码。

REA的iOS app就是这样的遗留系统。在多年以前，人们做了个决策，用CoreData做本地存储，替换掉NSUserDefaults。这之间的历史已经远不可考，但自从我加入项目以来，整个团队已经被它高昂的学习曲线、复杂的数据Migration流程以及过时陈旧的设计折磨的苦不堪言。于是我们决心把CoreData换掉。但直到我开始认真记录系统中有哪些类在调用CoreData API的时候，我才看清了原来CoreData只是这个复杂庞大的系统中种种问题的冰山一角而已。

## 系统面貌 ##

在一个有着良好分层结构的系统中，每一层都有它自己的职责：显示层负责响应用户事件，调用业务层的逻辑，最后做数据呈现；业务逻辑层负责业务规则与数据处理；数据访问层封装底层数据库的操作，网络访问层与其并列，负责网络请求、json解析等等。无论是MVC、MVVM、VIPER，归根结底都是在”单一职责“、“关注点分离”、“高内聚低耦合”的原则下变化，只是表现形式和涵盖的层次各异。

而在我们的代码中，几乎所有的显示层对象，包括ViewController、ViewModel，甚至View里面都混杂了大量的CoreData API调用，直接进行数据库操作。大概有以下两种方式

### 方式一 ###

初始化NSFetchedResultsController，然后发起请求

<img src="/assets/images/method_1.png" alt="" class="large">

### 方式二 ###

把自身当做CoreData的delegate，对数据库变化后作出响应

<img src="/assets/images/method_2.png" alt="" class="large">

粗略统计了一下，系统中一共有25个类与NSManageContext紧紧耦合。形成了下图中混乱的局面：

<img src="/assets/images/legacy_structure.png" alt="" class="large">

整理出来这幅图以后，看着眼前密密麻麻的API调用，看着众多臃肿庞大的ViewController，我的大脑几乎失去了思考的能力，不知道如何下手。

## 方案选型 ##

冷静过后，我最先排除掉的是*重写*这种简单粗暴的方式。表面上看来，我们可以通过重写得到一个干净利落的方案，层次结构清晰，职责分离；但与之相伴的是巨大的风险：

范围不可控——遗留系统的难点就在于牵一发而动全身，影响范围极广。稍不留神，重写的工作就会如野火燎原般蔓延开来，不可收拾。

长时间无法上线——在整个过程中，系统会处于一直不可用的状态，直到最后完成的那一刻。漫长的时间里，所有的新功能都被阻塞，不能交付。没有哪个产品团队能承担这样的结果。

第二个被排除掉的方案是*特性分支*。把重写的工作放到分支上完成，其他人继续在主干上开发新特性，直到重写结束再合并回主干——这种做法确实比直接重写要好上那么一点点，因为新特性还是可以不受影响的；但长期没有跟主干合并的分支，在经历上四五个月的重写之后，天知道到最后要花多长时间来处理合并冲突？

既想减小对系统的影响，又想不影响新功能上线，又不想处理大量的合并冲突，最后的方案就只剩下了一种，那就是抽象分支（Branch by Abstraction）+特性开关（Feature Toggle）。

### 抽象分支 ###

抽象分支这个名字的缘起是针对版本库分支而言的，它允许开发者在一条“抽象”的分支上并行工作，无需创建一条实际的分支，从而避免无谓的合并开销。[Martin Fowler](http://martinfowler.com/bliki/BranchByAbstraction.html)和[Jez Humble](http://continuousdelivery.com/2011/05/make-large-scale-changes-incrementally-with-branch-by-abstraction/)都曾在多年前撰文介绍过这个重构方案。

它的工作原理很简单：当我们想要替换掉系统中的某个组件——名为X——时，首先为X组件创造一个抽象层，这一层里面可能会有大大小小若干接口或是协议，把系统中对X组件的访问都隔离在抽象层之下，系统只调用抽象的接口/协议，不会接触到具体的API实现。如下图所示。

<img src="/assets/images/branch_by_abstraction_1.png" alt="">

这一步我们可以通过提取方法、提取类和接口等重构手法来完成；这以后系统就彻底跟X组件解耦了，它依赖的只是一组抽象接口，而非具体实现。这时候，我们就可以着手在这个抽象层下面，进行新组件的开发工作，让它也实现同一套接口即可。

<img src="/assets/images/branch_by_abstraction_2.png" alt="">

这之后，我们再使用特性开关（其原理及实现见下节），让这个抽象层在生产环境下调用旧组件，测试环境下调用新组件，从而在完全不影响交付的情况下，完成对新组件的测试。测试结束后，就可以打开开关，让系统在线上使用新组件，等彻底稳定后，把开关代码和旧组件代码全部删掉，替换工作就完成了。

<img src="/assets/images/branch_by_abstraction_3.png" alt="">

在上述整个开发过程中，任何一个阶段都可以做到细粒度的任务分解，然后小步提交，每次提交都自动触发单元测试和集成测试，保证不影响现有功能。在频繁提交的情况下，也不会出现大量的代码合并冲突，无论是做组件替换还是新特性开发，开发人员都可以基于同一套代码库工作。这就大大减少了对系统的冲击和交付风险。

下面介绍特性开关的原理与实现。

### 特性开关 ###

先看一段代码：

<img src="/assets/images/storyboard_toggle.png" alt="" class="large">

在这个例子中，我们要替换一个Storyboard的布局和相关ViewController的功能，耗时很久，如果直接在主干上修改，就会直接影响到现有的App，在功能完成之前都无法上线；如果拉一条分支出来做，未来就又会有大量的合并冲突。使用如上的特性开关就会避免上述问题。

当`shouldDisplayNewSearchResultsScreen`的值返回为真，就使用新的Storyboard，返回为假，就使用旧的Storyboard。这样一来，只要开关处于关闭状态，未完成的功能就是对用户不可见的，我们就既可以在开发环境下自测，也可以部署到测试环境下做验收测试，还可以针对开关为真的情况写对应的单元测试，让每次代码提交都有持续集成验证。这期间还可以继续发布新版本，用户完全感知不到影响，直到我们决定打开开关为止。

特性开关的实现方式是多样的：

#### 预编译参数 ####

<br/>在预编译参数中传值，让不同的xcconfig文件传入不同的值，然后在代码中做判断。例如我们可以定义internal和production两个Target，为内部发布和外部发布分别生成不同的ipa文件，然后在internal的xcconfig文件中定义

```
GCC_PREPROCESSOR_DEFINITIONS = INTERNAL_TARGET=1
```

而后就可以在Toggle代码中这样写

```
#ifdef INTERNAL_TARGET
#define isInternalTarget YES
#else
#define isInternalTarget NO
#endif

//本特性只在Internal Target中可见
+ (BOOL)shouldDisplayNewSearchResultsScreen
{
  return !isInternalTarget;
}
```

#### 服务器取值 ####

<br/>配置参数的值也可以通过服务器下发。这种做法的好处是比较灵活，在启用/禁用某项功能的时候不需要发布新版本，只需要后台配置，缺点是会增加集成和后台开发的工作量。

#### A/B测试 ####

<br/>还有一个办法是使用第三方的A/B测试服务，如果缺少后台开发人员的话，这也是一个选择。但第三方的稳定性往往就会成为制约因素，Parse为推送通知提供过A/B测试服务，但是它到了17年就会被关闭了；我们用Amazon的A/B测试框架用了一段时间，然后Amazon也宣布今年8月份停用A/B测试……目前我们还在寻找备选方案。

## 小结

到目前为止，本文简单描述了笔者所处团队中系统架构的问题和解决方案选型，在下一篇文章中，我将详细介绍如何组合使用抽象分支和特性开关，一步步用Realm替换掉CoreData，在这个过程中，我们从中获取了哪些经验教训。（待续）
